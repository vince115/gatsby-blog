function type(a) {
  const typeOf = typeof a;

  if (a === null) {
    return 'Null';
  } else if (a === undefined) {
    return 'Undefined';
  } else if (typeOf === 'boolean') {
    return 'Boolean';
  } else if (typeOf === 'number') {
    return 'Number';
  } else if (typeOf === 'string') {
    return 'String';
  } else if (Array.isArray(a)) {
    return 'Array';
  } else if (a instanceof RegExp) {
    return 'RegExp';
  }

  const asStr = a.toString();

  if (asStr.startsWith('async')) {
    return 'Async';
  } else if (asStr === '[object Promise]') {
    return 'Promise';
  } else if (asStr.includes('function') || asStr.includes('=>')) {
    return 'Function';
  }

  return 'Object';
}

function allFalse(...inputs) {
  let counter = 0;

  while (counter < inputs.length) {
    const x = inputs[counter];

    if (type(x) === 'Function') {
      if (inputs[counter]()) {
        return false;
      }
    } else if (inputs[counter]) {
      return false;
    }

    counter++;
  }

  return true;
}

function allTrue(...inputs) {
  let counter = 0;

  while (counter < inputs.length) {
    const x = inputs[counter];

    if (type(x) === 'Function') {
      if (!inputs[counter]()) {
        return false;
      }
    } else if (!inputs[counter]) {
      return false;
    }

    counter++;
  }

  return true;
}

function allType(targetType) {
  return (...inputs) => {
    let counter = 0;

    while (counter < inputs.length) {
      if (type(inputs[counter]) !== targetType) {
        return false;
      }

      counter++;
    }

    return true;
  };
}

function anyFalse(...inputs) {
  let counter = 0;

  while (counter < inputs.length) {
    if (!inputs[counter]) {
      return true;
    }

    counter++;
  }

  return false;
}

function anyTrue(...inputs) {
  let counter = 0;

  while (counter < inputs.length) {
    if (inputs[counter]) {
      return true;
    }

    counter++;
  }

  return false;
}

function anyType(targetType) {
  return (...inputs) => {
    let counter = 0;

    while (counter < inputs.length) {
      if (type(inputs[counter]) === targetType) {
        return true;
      }

      counter++;
    }

    return false;
  };
}

/**Used as the `TypeError` message for "Functions" methods. */
const FUNC_ERROR_TEXT = 'Expected a function';
/**Used to stand-in for `undefined` hash values. */

const HASH_UNDEFINED = '__lodash_hash_undefined__';
/**Used as references for various `Number` constants. */

let INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;
/**`Object#toString` result references. */

let funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';
/**Used to match property names within property paths. */

let reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/**Used to match backslashes in property paths. */

const reEscapeChar = /\\(\\)?/g;
/**Used to detect host constructors (Safari). */

const reIsHostCtor = /^\[object .+?Constructor\]$/;
/**Used to detect unsigned integer values. */

const reIsUint = /^(?:0|[1-9]\d*)$/;
/**Detect free variable `global` from Node.js. */

const freeGlobal = typeof global === 'object' && global && global.Object === Object && global;
/**Detect free variable `self`. */

const freeSelf = typeof self === 'object' && self && self.Object === Object && self;
/**Used as a reference to the global object. */

const root = freeGlobal || freeSelf || Function('return this')();
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function getValue(object, key) {
  return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */


function isHostObject(value) {
  //Many host objects are `Object` objects that can coerce to strings
  //despite having improperly defined `toString` methods.
  let result = false;

  if (value != null && typeof value.toString !== 'function') {
    try {
      result = Boolean(String(value));
    } catch (e) {}
  }

  return result;
}
/**Used for built-in method references. */


let arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;
/**Used to detect overreaching core-js shims. */

const coreJsData = root['__core-js_shared__'];
/**Used to detect methods masquerading as native. */

const maskSrcKey = function () {
  const uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**Used to resolve the decompiled source of functions. */


const funcToString = funcProto.toString;
/**Used to check objects for own properties. */

const hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

const objectToString = objectProto.toString;
/**Used to detect if a method is native. */

const reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**Built-in value references. */

let Symbol$1 = root.Symbol,
    splice = arrayProto.splice;
/*Built-in method references that are verified to be native. */

let Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');
/**Used to convert symbols to primitives and strings. */

let symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  let index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    const entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function hashGet(key) {
  const data = this.__data__;

  if (nativeCreate) {
    const result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function hashHas(key) {
  const data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */


function hashSet(key, value) {
  const data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
} //Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  let index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    const entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */


function listCacheClear() {
  this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function listCacheDelete(key) {
  let data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  const lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  let data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  let data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
} //Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  let index = -1,
      length = entries ? entries.length : 0;
  this.clear();

  while (++index < length) {
    const entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.__data__ = {
    hash: new Hash(),
    map: new (Map || ListCache)(),
    string: new Hash()
  };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  return getMapData(this, key).delete(key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
} //Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  const objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    object[key] = value;
  }
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  let length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */


function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  const pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = isKey(path, object) ? [path] : castPath(path);
  let index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    let key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      const objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */


function baseToString(value) {
  //Exit early for strings to avoid a performance hit in some environments.
  if (typeof value === 'string') {
    return value;
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  const result = String(value);
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  const data = map.__data__;
  return isKeyable(key) ? data[typeof key === 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  const value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */


function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return Boolean(length) && (typeof value === 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */


function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  const type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */


function isKeyable(value) {
  const type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return Boolean(maskSrcKey) && maskSrcKey in func;
}
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */


var stringToPath = memoize(string => {
  string = toString(string);
  const result = [];

  if (reLeadingDot.test(string)) {
    result.push('');
  }

  string.replace(rePropName, (match, number, quote, string) => {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value === 'string' || isSymbol(value)) {
    return value;
  }

  const result = String(value);
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */


function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return String(func);
    } catch (e) {}
  }

  return '';
}
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */


function memoize(func, resolver) {
  if (typeof func !== 'function' || resolver && typeof resolver !== 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    let args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    const result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} //Assign cache to `_.memoize`.


memoize.Cache = MapCache;
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

function eq(value, other) {
  return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */


var isArray = Array.isArray;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  //The use of `Object#toString` avoids issues with the `typeof` operator
  //in Safari 8-9 which returns 'object' for typed array and other constructors.
  const tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  const type = typeof value;
  return Boolean(value) && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return Boolean(value) && typeof value === 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return typeof value === 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}
/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */


function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

function whenObject(rule, hash) {
  const yes = {};
  const no = {};
  Object.entries(hash).forEach(([prop, value]) => {
    if (rule(value, prop)) {
      yes[prop] = value;
    } else {
      no[prop] = value;
    }
  });
  return [yes, no];
}

function partition(rule, list) {
  if (arguments.length === 1) {
    return listHolder => partition(rule, listHolder);
  }

  if (!Array.isArray(list)) return whenObject(rule, list);
  const yes = [];
  const no = [];
  let counter = -1;

  while (counter++ < list.length - 1) {
    if (rule(list[counter], counter)) {
      yes.push(list[counter]);
    } else {
      no.push(list[counter]);
    }
  }

  return [yes, no];
}

//Its lodash's set method taken from

const isObject$1 = x => {
  const ok = x !== null && !Array.isArray(x) && typeof x === 'object';

  if (!ok) {
    return false;
  }

  return Object.keys(x).length > 0;
};

function change(origin, pathRaw, rules) {
  const willReturn = JSON.parse(JSON.stringify(origin));

  if (!isObject$1(rules)) {
    set(willReturn, pathRaw, rules);
    return willReturn;
  }

  const path = pathRaw === '' ? '' : `${pathRaw}.`;

  for (const ruleKey of Object.keys(rules)) {
    const rule = rules[ruleKey];

    if (!isObject$1(rule)) {
      set(willReturn, `${path}${ruleKey}`, rule);
      continue;
    }

    const [withObjects, withoutObjects] = partition(subruleKey => isObject$1(rule[subruleKey]), Object.keys(rule));
    withoutObjects.forEach(subruleKey => {
      const subrule = rule[subruleKey];
      set(willReturn, `${path}${ruleKey}.${subruleKey}`, subrule);
    });
    withObjects.forEach(subruleKey => {
      const subrule = rule[subruleKey];
      Object.keys(subrule).forEach(deepKey => {
        const deep = rule[subruleKey][deepKey];

        if (!isObject$1(deep)) {
          return set(willReturn, `${path}${ruleKey}.${subruleKey}.${deepKey}`, deep);
        }

        Object.keys(deep).forEach(superDeepKey => {
          const superDeep = rule[subruleKey][deepKey][superDeepKey];
          set(willReturn, `${path}${ruleKey}.${subruleKey}.${deepKey}.${superDeepKey}`, superDeep);
        });
      });
    });
  }

  return willReturn;
}

function equals(a, b) {
  if (arguments.length === 1) {
    return bHolder => equals(a, bHolder);
  }

  if (a === b) {
    return true;
  }

  const aType = type(a);

  if (aType !== type(b)) {
    return false;
  }

  if (aType === 'Array') {
    const aClone = Array.from(a);
    const bClone = Array.from(b);

    if (aClone.toString() !== bClone.toString()) {
      return false;
    }

    let loopArrayFlag = true;
    aClone.forEach((aCloneInstance, aCloneIndex) => {
      if (loopArrayFlag) {
        if (aCloneInstance !== bClone[aCloneIndex] && !equals(aCloneInstance, bClone[aCloneIndex])) {
          loopArrayFlag = false;
        }
      }
    });
    return loopArrayFlag;
  }

  if (aType === 'Object') {
    const aKeys = Object.keys(a);

    if (aKeys.length !== Object.keys(b).length) {
      return false;
    }

    let loopObjectFlag = true;
    aKeys.forEach(aKeyInstance => {
      if (loopObjectFlag) {
        const aValue = a[aKeyInstance];
        const bValue = b[aKeyInstance];

        if (aValue !== bValue && !equals(aValue, bValue)) {
          loopObjectFlag = false;
        }
      }
    });
    return loopObjectFlag;
  }

  return false;
}

const forbidden = ['Null', 'Undefined', 'RegExp'];
const allowed = ['Number', 'Boolean'];
const notEmpty = ['Array', 'String'];
function compact(arr) {
  const willReturn = [];
  arr.forEach(a => {
    const currentType = type(a);
    if (forbidden.includes(currentType)) return;
    if (allowed.includes(currentType)) return willReturn.push(a);

    if (currentType === 'Object') {
      if (!equals(a, {})) willReturn.push(a);
      return;
    }

    if (!notEmpty.includes(currentType)) return;
    if (a.length === 0) return;
    willReturn.push(a);
  });
  return willReturn;
}

function composeAsync(...inputArguments) {
  return async function (startArgument) {
    let argumentsToPass = startArgument;

    while (inputArguments.length !== 0) {
      const fn = inputArguments.pop();
      const typeFn = type(fn);

      if (typeFn === 'Async') {
        argumentsToPass = await fn(argumentsToPass);
      } else {
        argumentsToPass = fn(argumentsToPass);
      }
    }

    return argumentsToPass;
  };
}

function compose(...fns) {
  return (...args) => {
    const list = fns.slice();

    if (list.length > 0) {
      const fn = list.pop();
      let result = fn(...args);

      while (list.length > 0) {
        result = list.pop()(result);
      }

      return result;
    }

    return undefined;
  };
}

function last(a) {
  if (typeof a === 'string') {
    return a[a.length - 1] || '';
  }

  return a[a.length - 1];
}

function baseSlice(array, start, end) {
  let index = -1;
  let length = array.length;
  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  const result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

function init(a) {
  if (typeof a === 'string') {
    return a.slice(0, -1);
  }

  return a.length ? baseSlice(a, 0, -1) : [];
}

function composed(...inputs) {
  return compose(...init(inputs))(last(inputs));
}

function count(target, list) {
  if (arguments.length === 1) {
    return listHolder => count(target, listHolder);
  }

  if (!Array.isArray(list)) return 0;
  return list.filter(x => equals(x, target)).length;
}

function debounce(func, ms, immediate = false) {
  let timeout;
  return function (...input) {
    const later = function () {
      timeout = null;

      if (!immediate) {
        func.apply(null, input);
      }
    };

    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, ms);

    if (callNow) {
      func.apply(null, input);
    }
  };
}

function flagIs(targetType, input) {
  if (!input) return false;
  if (type(input) !== targetType) return false;
  if (targetType === 'Array') return !equals([], input);
  if (targetType === 'Object') return !equals({}, input);
  return true;
}

function defaultToStrict(defaultArgument, ...inputArguments) {
  if (arguments.length === 1) {
    return inputArgumentsHolder => defaultToStrict(defaultArgument, inputArgumentsHolder);
  }

  if (arguments.length === 2) {
    return flagIs(type(defaultArgument), inputArguments[0]) ? inputArguments[0] : defaultArgument;
  }

  const targetType = type(defaultArgument);
  const limit = inputArguments.length - 1;
  let len = limit + 1;
  let ready = false;
  let holder;

  while (!ready) {
    const instance = inputArguments[limit - len + 1];

    if (len === 0) {
      ready = true;
    } else if (flagIs(targetType, instance)) {
      holder = instance;
      ready = true;
    } else {
      len -= 1;
    }
  }

  return holder === undefined ? defaultArgument : holder;
}

function defaultToWhen(defaultArgument, fn, ...inputArguments) {
  if (arguments.length === 2) {
    return (...inputArgumentsHolder) => defaultToWhen(defaultArgument, fn, ...inputArgumentsHolder);
  }

  const limit = inputArguments.length - 1;
  let len = limit + 1;
  let ready = false;
  let holder;

  while (!ready) {
    const instance = inputArguments[limit - len + 1];

    if (len === 0) {
      ready = true;
    } else if (fn(instance) === true) {
      holder = instance;
      ready = true;
    } else {
      len = len - 1;
    }
  }

  return holder === undefined ? defaultArgument : holder;
}

function delay(ms) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('RAMBDAX_DELAY');
    }, ms);
  });
}

function findInObject(fn, obj) {
  if (arguments.length === 1) {
    return objHolder => findInObject(fn, objHolder);
  }

  let willReturn = {
    fallback: true
  };
  Object.entries(obj).forEach(([prop, value]) => {
    if (willReturn.fallback) {
      if (fn(value, prop)) {
        willReturn = {
          prop,
          value
        };
      }
    }
  });
  return willReturn;
}

//WAIT
function findModify(fn, list) {
  if (arguments.length === 1) {
    return listHolder => findModify(fn, listHolder);
  }

  const len = list.length;
  if (len === 0) return false;
  let index = -1;

  while (++index < len) {
    const result = fn(list[index], index);

    if (result !== false) {
      return result;
    }
  }

  return false;
}

function flatMap(fn, xs) {
  if (arguments.length === 1) {
    return xsHolder => flatMap(fn, xsHolder);
  }

  return [].concat(...xs.map(fn));
}

function pick(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => pick(keys, objHolder);
  }

  if (obj === null || obj === undefined) {
    return undefined;
  }

  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;
  const willReturn = {};
  let counter = 0;

  while (counter < keysValue.length) {
    if (keysValue[counter] in obj) {
      willReturn[keysValue[counter]] = obj[keysValue[counter]];
    }

    counter++;
  }

  return willReturn;
}

function merge(obj, newProps) {
  if (arguments.length === 1) {
    return newPropsHolder => merge(obj, newPropsHolder);
  }

  return Object.assign({}, obj || {}, newProps || {});
}

let holder = {};
/**
 * Pass string to get value
 * Pass array to get object of values
 * Pass undefined to get all data
 */

function getter(key) {
  const typeKey = type(key);
  if (typeKey === 'String') return holder[key];
  if (typeKey === 'Array') return pick(key, holder);
  return holder;
}
function setter(maybeKey, maybeValue) {
  const typeKey = type(maybeKey);
  const typeValue = type(maybeValue);

  if (typeKey === 'String') {
    if (typeValue === 'Function') {
      return holder[maybeKey] = maybeValue(holder[maybeKey]);
    }

    return holder[maybeKey] = maybeValue;
  }

  if (typeKey !== 'Object') return;
  holder = merge(holder, maybeKey);
}
function reset() {
  holder = {};
}

function glue(input, glue) {
  return input.split('\n').filter(x => x.trim().length > 0).map(x => x.trim()).join(glue !== undefined ? glue : ' ');
}

function path(pathArr, obj) {
  if (arguments.length === 1) {
    return objHolder => path(pathArr, objHolder);
  }

  if (obj === null || obj === undefined) {
    return undefined;
  }

  let willReturn = obj;
  let counter = 0;
  const pathArrValue = typeof pathArr === 'string' ? pathArr.split('.') : pathArr;

  while (counter < pathArrValue.length) {
    if (willReturn === null || willReturn === undefined) {
      return undefined;
    }

    willReturn = willReturn[pathArrValue[counter]];
    counter++;
  }

  return willReturn;
}

function hasPath(maybePath, obj) {
  if (arguments.length === 1) {
    return objHolder => hasPath(maybePath, objHolder);
  }

  return path(maybePath, obj) !== undefined;
}

function headObject(input) {
  const [head, _] = Object.entries(input);
  if (!head) return {
    prop: undefined,
    value: undefined
  };
  if (_) throw new Error('R.headObject expects object with only one key');
  return {
    prop: head[0],
    value: head[1]
  };
}

function createThenable(x) {
  return async function (input) {
    return x(input);
  };
}

function ifElseAsync(condition, ifFn, elseFn) {
  return input => new Promise((resolve, reject) => {
    const conditionPromise = createThenable(condition);
    const ifFnPromise = createThenable(ifFn);
    const elseFnPromise = createThenable(elseFn);
    conditionPromise(input).then(conditionResult => {
      const promised = conditionResult === true ? ifFnPromise : elseFnPromise;
      promised(input).then(resolve).catch(reject);
    }).catch(reject);
  });
}

function any(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => any(fn, arrHolder);
  }

  let counter = 0;

  while (counter < arr.length) {
    if (fn(arr[counter], counter)) {
      return true;
    }

    counter++;
  }

  return false;
}

function expensiveIncludes(target, source) {
  return any(singleSource => equals(target, singleSource), source);
}

function includesAny(targets, source) {
  if (arguments.length === 1) {
    return sourceHolder => includesAny(targets, sourceHolder);
  }

  const sourceType = type(source);

  if (['Array', 'String'].includes(sourceType) === false) {
    return false;
  }

  if (sourceType === 'String') {
    return any(x => source.includes(x), targets);
  }

  return any(x => expensiveIncludes(x, source), targets);
}

function includesType(targetType, list) {
  if (arguments.length === 1) {
    return listHolder => includesType(targetType, listHolder);
  }

  return any(x => type(x) === targetType, list);
}

function replace(regex, replacer, str) {
  if (replacer === undefined) {
    return (replacerHolder, strHolder) => replace(regex, replacerHolder, strHolder);
  } else if (str === undefined) {
    return strHolder => replace(regex, replacer, strHolder);
  }

  return str.replace(regex, replacer);
}

function inject(injection, marker, content) {
  return replace(marker, `${marker}${injection}`, content);
}

function take(num, x) {
  if (arguments.length === 1) return xHolder => take(num, xHolder);

  if (typeof x === 'string') {
    return x.slice(0, num);
  }

  return baseSlice(x, 0, num);
}

function shuffle(arrayRaw) {
  const array = arrayRaw.concat();
  let counter = array.length;

  while (counter > 0) {
    const index = Math.floor(Math.random() * counter);
    counter--;
    const temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }

  return array;
}

const uuidList = '0123456789qwertyuiopasdfghjklzxcvbnm'.split('');

function uuid() {
  return take(5, shuffle(uuidList).join(''));
}

const holder$1 = {};
function interval({
  fn,
  ms,
  whenStop
}) {
  const key = uuid();
  return new Promise(resolve => {
    holder$1[key] = setInterval(() => {
      if (whenStop() === true) {
        clearInterval(holder$1[key]);
        resolve();
      } else {
        fn();
      }
    }, ms);
  });
}

function toLower(x) {
  return x.toLowerCase();
}

function contains(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => contains(x, arrHolder);
  }

  let index = -1;
  let flag = false;

  while (++index < arr.length && !flag) {
    if (equals(arr[index], x)) {
      flag = true;
    }
  }

  return flag;
}

function test$1(regex, str) {
  if (arguments.length === 1) return strHolder => test$1(regex, strHolder);
  return str.search(regex) !== -1;
}

function filterObject(fn, obj) {
  const willReturn = {};

  for (const prop in obj) {
    if (fn(obj[prop], prop)) {
      willReturn[prop] = obj[prop];
    }
  }

  return willReturn;
}

function filter(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => filter(fn, arrHolder);
  }

  if (arr === undefined) {
    return [];
  }

  if (!Array.isArray(arr)) {
    return filterObject(fn, arr);
  }

  let index = -1;
  let resIndex = 0;
  const len = arr.length;
  const willReturn = [];

  while (++index < len) {
    const value = arr[index];

    if (fn(value, index)) {
      willReturn[resIndex++] = value;
    }
  }

  return willReturn;
}

function all(condition, arr) {
  if (arguments.length === 1) {
    return arrHolder => all(condition, arrHolder);
  }

  return filter(condition, arr).length === arr.length;
}

function fromPrototypeToString(rule, ruleType) {
  if (ruleType !== 'Function') return {
    rule,
    parsed: false
  };

  if (typeof rule.prototype === 'function' || rule.prototype === undefined) {
    return {
      rule,
      parsed: false
    };
  }

  if (String.prototype === rule.prototype) {
    return {
      rule: 'string',
      parsed: true
    };
  }

  if (Boolean.prototype === rule.prototype) {
    return {
      rule: 'boolean',
      parsed: true
    };
  }

  if (Number.prototype === rule.prototype) {
    return {
      rule: 'number',
      parsed: true
    };
  }

  return {
    rule: type(rule.prototype).toLowerCase(),
    parsed: true
  };
}

function getRuleAndType(schema, requirementRaw) {
  const ruleRaw = schema[requirementRaw];
  const typeIs = type(ruleRaw);
  const {
    rule,
    parsed
  } = fromPrototypeToString(ruleRaw, typeIs);
  return {
    rule: rule,
    ruleType: parsed ? 'String' : typeIs
  };
}

function isValid({
  input,
  schema
}) {
  if (input === undefined || schema === undefined) return false;
  let flag = true;

  const boom = boomFlag => {
    if (!boomFlag) {
      flag = false;
    }
  };

  for (const requirementRaw in schema) {
    if (flag) {
      const isOptional = requirementRaw.endsWith('?');
      const requirement = isOptional ? init(requirementRaw) : requirementRaw;
      const {
        rule,
        ruleType
      } = getRuleAndType(schema, requirementRaw);
      const inputProp = input[requirement];
      const inputPropType = type(input[requirement]);
      const ok = isOptional && inputProp !== undefined || !isOptional;
      if (!ok || rule === 'any' && inputProp != null || rule === inputProp) continue;

      if (ruleType === 'Object') {
        /**
         * This rule is standalone schema, so we recursevly call `isValid`
         */
        const isValidResult = isValid({
          input: inputProp,
          schema: rule
        });
        boom(isValidResult);
      } else if (ruleType === 'String') {
        /**
         * Rule is actual rule such as 'number', so the two types are compared
         */
        boom(toLower(inputPropType) === rule);
      } else if (typeof rule === 'function') {
        /**
         * Rule is function so we pass to it the input
         */
        boom(rule(inputProp));
      } else if (ruleType === 'Array' && inputPropType === 'String') {
        /**
         * Enum case | rule is like a: ['foo', 'bar']
         */
        boom(contains(inputProp, rule));
      } else if (ruleType === 'Array' && rule.length === 1 && inputPropType === 'Array') {
        /**
         * 1. array of type | rule is like a: ['number']
         * 2. rule is like a: [{from: 'string'}]
         */
        const currentRule = rule[0];
        const currentRuleType = type(rule[0]); //Check if rule is invalid

        boom(currentRuleType === 'String' || currentRuleType === 'Object');

        if (currentRuleType === 'String') {
          /**
           * 1. array of type
           */
          const isInvalidResult = any(inputPropInstance => type(inputPropInstance).toLowerCase() !== currentRule, inputProp);
          boom(!isInvalidResult);
        }

        if (currentRuleType === 'Object') {
          /**
           * 2. rule is like a: [{from: 'string'}]
           */
          const isValidResult = all(inputPropInstance => isValid({
            input: inputPropInstance,
            schema: currentRule
          }), inputProp);
          boom(isValidResult);
        }
      } else if (ruleType === 'RegExp' && inputPropType === 'String') {
        boom(test$1(rule, inputProp));
      } else {
        boom(false);
      }
    }
  }

  return flag;
}

function isAttach() {
  if (Object.prototype.is !== undefined) {
    return false;
  }

  Object.defineProperty(Object.prototype, 'is', {
    value: function (schema) {
      return isValid({
        input: {
          isProp: this
        },
        schema: {
          isProp: schema
        }
      });
    },
    writable: true,
    configurable: true
  });
  return true;
}

function isFunction$1(fn) {
  return ['Async', 'Promise', 'Function'].includes(type(fn));
}

function isFalsy(x) {
  const typeIs = type(x);
  if (['Array', 'String'].includes(typeIs)) return x.length === 0;
  if (typeIs === 'Object') return Object.keys(x).length === 0;
  if (['Null', 'Undefined'].includes(typeIs)) return true;
  return false;
}

function isPromise(x) {
  return ['Async', 'Promise'].includes(type(x));
}

function isType(xType, x) {
  if (arguments.length === 1) {
    return xHolder => isType(xType, xHolder);
  }

  return type(x) === xType;
}

async function mapAsyncFn(fn, arr) {
  if (Array.isArray(arr)) {
    const willReturn = [];

    for (const a of arr) {
      willReturn.push((await fn(a)));
    }

    return willReturn;
  }

  const willReturn = {};

  for (const prop in arr) {
    willReturn[prop] = await fn(arr[prop], prop);
  }

  return willReturn;
}

function mapAsync(fn, arr) {
  if (arguments.length === 1) {
    return async holder => mapAsyncFn(fn, holder);
  }

  return new Promise((resolve, reject) => {
    mapAsyncFn(fn, arr).then(resolve).catch(reject);
  });
}

async function mapFastAsyncFn(fn, arr) {
  const promised = arr.map(a => fn(a));
  return await Promise.all(promised);
}

function mapFastAsync(fn, arr) {
  if (arguments.length === 1) {
    return async holder => mapFastAsyncFn(fn, holder);
  }

  return new Promise((resolve, reject) => {
    mapFastAsyncFn(fn, arr).then(resolve).catch(reject);
  });
}

function mapObject(fn, obj) {
  const willReturn = {};

  for (const prop in obj) {
    willReturn[prop] = fn(obj[prop], prop);
  }

  return willReturn;
}

function map(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => map(fn, arrHolder);
  }

  if (arr === undefined) {
    return [];
  }

  if (!Array.isArray(arr)) {
    return mapObject(fn, arr);
  }

  let index = -1;
  const len = arr.length;
  const willReturn = Array(len);

  while (++index < len) {
    willReturn[index] = fn(arr[index], index);
  }

  return willReturn;
}

function mergeAll(arr) {
  let willReturn = {};
  map(val => {
    willReturn = merge(willReturn, val);
  }, arr);
  return willReturn;
}

function check(singleInput, schema) {
  return isValid({
    input: {
      singleInput
    },
    schema: {
      singleInput: schema
    }
  });
}
function ok(...inputs) {
  return (...schemas) => {
    let failedSchema;
    const pass = any((singleInput, i) => {
      const schema = schemas[i] === undefined ? schemas[0] : schemas[i];
      const checked = check(singleInput, schema);

      if (!checked) {
        failedSchema = JSON.stringify({
          input: singleInput,
          schema
        });
      }

      return !checked;
    }, inputs) === false;
    if (!pass) throw new Error(`Failed R.ok with schema ${failedSchema}`);
    return true;
  };
}

function mapToObject(fn, list) {
  if (arguments.length === 1) {
    return listHolder => mapToObject(fn, listHolder);
  }

  ok(type(fn), type(list))('Function', 'Array');
  return mergeAll(map(fn, list));
}

function maybe(ifRule, whenIfRaw, whenElseRaw) {
  const whenIf = ifRule && type(whenIfRaw) === 'Function' ? whenIfRaw() : whenIfRaw;
  const whenElse = !ifRule && type(whenElseRaw) === 'Function' ? whenElseRaw() : whenElseRaw;
  return ifRule ? whenIf : whenElse;
}

function sort(fn, arr) {
  if (arguments.length === 1) return arrHolder => sort(fn, arrHolder);
  const arrClone = arr.concat();
  return arrClone.sort(fn);
}

const cache = {};

const normalizeObject = obj => {
  const sortFn = (a, b) => a > b;

  const willReturn = {};
  compose(map(prop => willReturn[prop] = obj[prop]), sort(sortFn))(Object.keys(obj));
  return willReturn;
};

const stringify = a => {
  if (type(a) === 'String') {
    return a;
  } else if (['Function', 'Async'].includes(type(a))) {
    const compacted = replace(/\s{1,}/g, ' ', a.toString());
    return replace(/\s/g, '_', take(15, compacted));
  } else if (type(a) === 'Object') {
    a = normalizeObject(a);
  }

  return JSON.stringify(a);
};

const generateProp = (fn, ...inputArguments) => {
  let propString = '';
  inputArguments.forEach(inputArgument => {
    propString += `${stringify(inputArgument)}_`;
  });
  return `${propString}${stringify(fn)}`;
};

function memoize$1(fn, ...inputArguments) {
  if (arguments.length === 1) {
    return (...inputArgumentsHolder) => memoize$1(fn, ...inputArgumentsHolder);
  }

  const prop = generateProp(fn, ...inputArguments);
  if (prop in cache) return cache[prop];

  if (type(fn) === 'Async') {
    return new Promise(resolve => {
      fn(...inputArguments).then(result => {
        cache[prop] = result;
        resolve(result);
      });
    });
  }

  const result = fn(...inputArguments);
  cache[prop] = result;
  return result;
}

function mergeRight(x, y) {
  return merge(y, x);
}

function mergeDeep(target, source) {
  if (arguments.length === 1) {
    return sourceHolder => mergeDeep(target, sourceHolder);
  }

  const willReturn = JSON.parse(JSON.stringify(target));
  Object.keys(source).forEach(key => {
    if (type(source[key]) === 'Object') {
      if (type(target[key]) === 'Object') {
        willReturn[key] = mergeDeep(target[key], source[key]);
      } else {
        willReturn[key] = source[key];
      }
    } else {
      willReturn[key] = source[key];
    }
  });
  return willReturn;
}

function nextIndex(index, list) {
  const newIndex = index === list.length - 1 ? 0 : index + 1;
  return newIndex;
}

function pass(...inputs) {
  return (...schemas) => any((x, i) => {
    const schema = schemas[i] === undefined ? schemas[0] : schemas[i];
    return !check(x, schema);
  }, inputs) === false;
}

//taken from the last comment of https://gist.github.com/mkuklis/5294248
function curry(f, a = []) {
  return (...p) => (o => o.length >= f.length ? f(...o) : curry(f, o))([...a, ...p]);
}

function onceFn(fn, context) {
  let result;
  return function () {
    if (fn) {
      result = fn.apply(context || this, arguments);
      fn = null;
    }

    return result;
  };
}

function once(fn, context) {
  if (arguments.length === 1) {
    const wrap = onceFn(fn, context);
    return curry(wrap);
  }

  return onceFn(fn, context);
}

function otherwise(fallback, toResolve) {
  if (arguments.length === 1) {
    return toResolveHolder => otherwise(fallback, toResolveHolder);
  }

  return new Promise(resolve => {
    toResolve.then(resolve).catch(e => resolve(fallback(e)));
  });
}

function pathEq(path$$1, target, obj) {
  if (arguments.length === 2) {
    return objHolder => pathEq(path$$1, target, objHolder);
  }

  return path(path$$1, obj) === target;
}

function pipe(...fns) {
  return compose(...fns.reverse());
}

function piped(...inputs) {
  const [input, ...fnList] = inputs;
  return pipe(...fnList)(input);
}

async function pipedAsync(...inputs) {
  const [input, ...fnList] = inputs;
  let argumentsToPass = input;

  while (fnList.length !== 0) {
    const fn = fnList.shift();
    const typeFn = type(fn);

    if (typeFn === 'Async') {
      argumentsToPass = await fn(argumentsToPass);
    } else {
      argumentsToPass = fn(argumentsToPass);
    }
  }

  return argumentsToPass;
}

function helper({
  condition,
  inputArgument,
  prop
}) {
  return new Promise((resolve, reject) => {
    if (!(type(condition) === 'Async')) {
      return resolve({
        type: prop,
        payload: condition(inputArgument)
      });
    }

    condition(inputArgument).then(result => {
      resolve({
        type: prop,
        payload: result
      });
    }).catch(err => reject(err));
  });
}

function produce(conditions, inputArgument) {
  if (arguments.length === 1) {
    return inputArgumentHolder => produce(conditions, inputArgumentHolder);
  }

  let asyncConditionsFlag = false;

  for (const prop in conditions) {
    if (asyncConditionsFlag === false && type(conditions[prop]) === 'Async') {
      asyncConditionsFlag = true;
    }
  }

  if (asyncConditionsFlag === false) {
    const willReturn = {};

    for (const prop in conditions) {
      willReturn[prop] = conditions[prop](inputArgument);
    }

    return willReturn;
  }

  const promised = [];

  for (const prop in conditions) {
    const condition = conditions[prop];
    promised.push(helper({
      inputArgument,
      condition,
      prop
    }));
  }

  return new Promise((resolve, reject) => {
    Promise.all(promised).then(results => {
      const willReturn = {};
      map(result => willReturn[result.type] = result.payload, results);
      resolve(willReturn);
    }).catch(err => reject(err));
  });
}

function promiseAllObject(promises) {
  return new Promise((res, rej) => {
    let counter = 0;
    const props = {};
    const promisedArr = [];

    for (const prop in promises) {
      props[counter] = prop;
      promisedArr.push(promises[prop]);
      counter++;
    }

    Promise.all(promisedArr).then(result => {
      const willReturn = {};
      result.map((val, key) => {
        const prop = props[key];
        willReturn[prop] = val;
      });
      res(willReturn);
    }).catch(rej);
  });
}

function pushUniq(x, list) {
  if (list.includes(x)) return;
  list.push(x);
}

function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function remove(inputs, text) {
  if (arguments.length === 1) {
    return textHolder => remove(inputs, textHolder);
  }

  if (type(text) !== 'String') {
    throw new Error(`R.remove requires string not ${type(text)}`);
  }

  if (type(inputs) !== 'Array') {
    return replace(inputs, '', text).trim();
  }

  let textCopy = text;
  inputs.forEach(singleInput => {
    textCopy = replace(singleInput, '', textCopy).trim();
  });
  return textCopy;
}

function omit(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => omit(keys, objHolder);
  }

  if (obj === null || obj === undefined) {
    return undefined;
  }

  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;
  const willReturn = {};

  for (const key in obj) {
    if (!keysValue.includes(key)) {
      willReturn[key] = obj[key];
    }
  }

  return willReturn;
}

function renameProps(conditions, inputObject) {
  if (inputObject === undefined) {
    return inputObjectHolder => renameProps(conditions, inputObjectHolder);
  }

  const renamed = {};
  Object.keys(conditions).forEach(renameConditionProp => {
    if (Object.keys(inputObject).includes(renameConditionProp)) {
      renamed[conditions[renameConditionProp]] = inputObject[renameConditionProp];
    }
  });
  return merge(renamed, omit(Object.keys(conditions), inputObject));
}

function resolve(afterResolve, toResolve) {
  if (arguments.length === 1) {
    return toResolveHolder => resolve(afterResolve, toResolveHolder);
  }

  return new Promise(res => {
    toResolve.then(result => res(afterResolve(result)));
  });
}

const getOccurances = input => input.match(/{{[_a-zA-Z0-9]+}}/g);

const getOccuranceProp = occurance => occurance.replace(/{{|}}/g, '');

const replace$1 = ({
  inputHolder,
  prop,
  replacer
}) => inputHolder.replace(`{{${prop}}}`, replacer);

function template(input, templateInput) {
  if (arguments.length === 1) {
    return templateInputHolder => template(input, templateInputHolder);
  }

  const occurances = getOccurances(input);
  if (occurances === null) return input;
  let inputHolder = input;

  for (const occurance of occurances) {
    const prop = getOccuranceProp(occurance);
    const replacer = templateInput[prop];
    if (replacer === undefined) continue;
    inputHolder = replace$1({
      inputHolder,
      prop,
      replacer
    });
  }

  return inputHolder;
}

function headObject$1(x) {
  if (type(x) !== 'Object') throw new Error('R.headObject.type');
  const [tag, no] = Object.keys(x);
  if (tag === undefined) throw new Error('R.headObject.less');
  if (no !== undefined) throw new Error('R.headObject.more');
  return {
    prop: tag,
    value: x[tag]
  };
}

const evaluationsSchema = {
  label: 'string'
};
function runTests(input) {
  const pass$$1 = pass(input)({
    testSuite: 'string',
    evaluations: [evaluationsSchema]
  });

  if (describe === undefined || !pass$$1) {
    throw new Error('R.runTests.init');
  }

  try {
    const {
      testSuite,
      evaluations,
      data
    } = input;
    describe(testSuite, () => {
      evaluations.forEach(singleEvaluation => {
        data.forEach(dataInstance => {
          const {
            prop: tag,
            value: x
          } = headObject$1(dataInstance);
          const {
            value: evaluationFunction
          } = headObject$1(omit('label', singleEvaluation));
          const label = template(singleEvaluation.label, {
            tag
          });
          test(label, () => {
            evaluationFunction(x);
          });
        });
      });
    });
  } catch (err) {
    console.log(err);
    throw new Error('R.runTestsCatch');
  }
}

//https://github.com/staltz/zii
function s() {
  if (Object.prototype.s === undefined) {
    Object.defineProperty(Object.prototype, 's', {
      value: function (f) {
        return f(this.valueOf());
      },
      writable: true,
      configurable: true
    });
    return true;
  }

  return false;
}

const NO_MATCH_FOUND = Symbol ? Symbol('NO_MATCH_FOUND') : undefined;

const getMatchingKeyValuePair = (cases, testValue, defaultValue) => {
  let iterationValue;

  for (let index = 0; index < cases.length; index++) {
    iterationValue = cases[index].test(testValue);

    if (iterationValue !== NO_MATCH_FOUND) {
      return iterationValue;
    }
  }

  return defaultValue;
};

const isEqual = (testValue, matchValue) => {
  const willReturn = typeof testValue === 'function' ? testValue(matchValue) : equals(testValue, matchValue);
  return willReturn;
};

const is = (testValue, matchResult = true) => ({
  key: testValue,
  test: matchValue => isEqual(testValue, matchValue) ? matchResult : NO_MATCH_FOUND
});

class Switchem {
  constructor(defaultValue, cases, willMatch) {
    if (defaultValue !== undefined && cases === undefined && willMatch === undefined) {
      this.cases = [];
      this.defaultValue = undefined;
      this.willMatch = defaultValue;
    } else {
      this.cases = cases;
      this.defaultValue = defaultValue;
      this.willMatch = willMatch;
    }

    return this;
  }

  default(defaultValue) {
    const holder = new Switchem(defaultValue, this.cases, this.willMatch);
    return holder.match(this.willMatch);
  }

  is(testValue, matchResult) {
    return new Switchem(this.defaultValue, [...this.cases, is(testValue, matchResult)], this.willMatch);
  }

  match(matchValue) {
    return getMatchingKeyValuePair(this.cases, matchValue, this.defaultValue);
  }

}

function switcher(input) {
  return new Switchem(input);
}

function tapAsync(fn, input) {
  if (arguments.length === 1) {
    return inputHolder => tapAsync(fn, inputHolder);
  }

  if (isPromise(fn) === true) {
    return new Promise((resolve, reject) => {
      fn(input).then(() => {
        resolve(input);
      }).catch(reject);
    });
  }

  fn(input);
  return input;
}

function throttle(fn, ms) {
  let wait = false;
  return function (...input) {
    if (!wait) {
      fn.apply(null, input);
      wait = true;
      setTimeout(() => {
        wait = false;
      }, ms);
    }
  };
}

function tryCatch(fn, fallback) {
  if (!isFunction$1(fn)) {
    throw new Error(`R.tryCatch | fn '${fn}'`);
  }

  const passFallback = isFunction$1(fallback);

  if (!isPromise(fn)) {
    return (...inputs) => {
      try {
        return fn(...inputs);
      } catch (e) {
        return passFallback ? fallback(...inputs) : fallback;
      }
    };
  }

  return (...inputs) => new Promise(resolve => {
    fn(...inputs).then(resolve).catch(() => {
      if (!passFallback) {
        return resolve(fallback);
      }

      if (!isPromise(fallback)) {
        return resolve(fallback(...inputs));
      }

      fallback(...inputs).then(resolve);
    });
  });
}

function unless(condition, whenFalse) {
  if (arguments.length === 1) {
    return whenFalseHolder => unless(condition, whenFalseHolder);
  }

  return input => {
    const flag = typeof condition === 'boolean' ? condition : condition(input);
    if (flag) return input;
    if (isFunction$1(whenFalse)) return whenFalse(input);
    return whenFalse;
  };
}

function wait(fn) {
  return new Promise(resolve => {
    fn.then(result => resolve([result])).catch(e => resolve([, e]));
  });
}

function range(start, end) {
  if (arguments.length === 1) return endHolder => range(start, endHolder);
  const willReturn = [];

  for (let i = start; i < end; i++) {
    willReturn.push(i);
  }

  return willReturn;
}

function waitFor(condition, howLong, loops = 10) {
  const typeCondition = type(condition);
  const passPromise = typeCondition === 'Async';
  const passFunction = typeCondition === 'Function';
  const interval = Math.floor(howLong / loops);

  if (!(passPromise || passFunction)) {
    throw new Error('R.waitFor');
  }

  if (passFunction) {
    return async (...inputs) => {
      for (const i of range(0, loops)) {
        // deepscan-disable-line
        const resultCondition = condition(...inputs);

        if (resultCondition === false) {
          await delay(interval);
        } else {
          return resultCondition;
        }
      }

      return false;
    };
  }

  return async (...inputs) => {
    for (const i of range(0, loops)) {
      const resultCondition = await condition(...inputs);

      if (resultCondition === false) {
        await delay(interval);
      } else {
        return resultCondition;
      }
    }

    return false;
  };
}

function when(condition, whenTrue) {
  if (arguments.length === 1) {
    return whenTrueHolder => when(condition, whenTrueHolder);
  }

  return input => {
    const flag = typeof condition === 'boolean' ? condition : condition(input);
    if (!flag) return input;
    if (isFunction$1(whenTrue)) return whenTrue(input);
    return whenTrue;
  };
}

function createThenable$1(x) {
  return async function (input) {
    return x(input);
  };
}

function whenAsync(condition, whenTrueFn) {
  if (arguments.length === 1) {
    return whenTrueFnHolder => whenAsync(condition, whenTrueFnHolder);
  }

  return input => new Promise((resolve, reject) => {
    const whenTrueFnPromise = createThenable$1(whenTrueFn);

    if (typeof condition === 'boolean') {
      if (condition === false) {
        return resolve(input);
      }

      whenTrueFnPromise(input).then(resolve).catch(reject);
    } else {
      const conditionPromise = createThenable$1(condition);
      conditionPromise(input).then(conditionResult => {
        if (conditionResult === false) {
          return resolve(input);
        }

        whenTrueFnPromise(input).then(resolve).catch(reject);
      }).catch(reject);
    }
  });
}

function where(conditions, obj) {
  if (obj === undefined) {
    return objHolder => where(conditions, objHolder);
  }

  let flag = true;

  for (const prop in conditions) {
    const result = conditions[prop](obj[prop]);

    if (flag && result === false) {
      flag = false;
    }
  }

  return flag;
}

function whereEq(rule, input) {
  if (arguments.length === 1) {
    return inputHolder => whereEq(rule, inputHolder);
  }

  if (type(input) !== 'Object') return false;
  const result = filter((ruleValue, ruleProp) => equals(ruleValue, input[ruleProp]), rule);
  return Object.keys(result).length === Object.keys(rule).length;
}

function add(x, y) {
  if (y === undefined) {
    return yHolder => add(x, yHolder);
  }

  return x + y;
}

function adjustRaw(fn, index, arr) {
  const clone = arr.concat();
  return clone.map((val, key) => {
    if (key === index) {
      return fn(arr[index]);
    }

    return val;
  });
}

const adjust = curry(adjustRaw);

function allPass(conditions, x) {
  if (arguments.length === 1) {
    return xHolder => allPass(conditions, xHolder);
  }

  return !any(condition => !condition(x), conditions);
}

function always(x) {
  return () => x;
}

function anyPass(conditions, x) {
  if (arguments.length === 1) {
    return xHolder => anyPass(conditions, xHolder);
  }

  return any(condition => condition(x))(conditions);
}

function append(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => append(x, arrHolder);
  }

  if (typeof arr === 'string') return `${arr}${x}`;
  const clone = arr.concat();
  clone.push(x);
  return clone;
}

function assocRaw(prop, value, obj) {
  return Object.assign({}, obj, {
    [prop]: value
  });
}

const assoc = curry(assocRaw);

function both(x, y) {
  if (arguments.length === 1) {
    return yHolder => both(x, yHolder);
  }

  return input => x(input) && y(input);
}

function complement(fn) {
  return input => !fn(input);
}

function concat(x, y) {
  if (arguments.length === 1) {
    return yHolder => concat(x, yHolder);
  }

  return typeof x === 'string' ? `${x}${y}` : [...x, ...y];
}

const dec = x => x - 1;

function flagIs$1(inputArgument) {
  return inputArgument === undefined || inputArgument === null || Number.isNaN(inputArgument) === true;
}

function defaultTo(defaultArgument, ...inputArgument) {
  if (arguments.length === 1) {
    return inputArgumentHolder => defaultTo(defaultArgument, inputArgumentHolder);
  }

  if (arguments.length === 2) {
    return flagIs$1(inputArgument[0]) ? defaultArgument : inputArgument[0];
  }

  const limit = inputArgument.length - 1;
  let len = limit + 1;
  let ready = false;
  let holder;

  while (!ready) {
    const instance = inputArgument[limit - len + 1];

    if (len === 0) {
      ready = true;
    } else if (flagIs$1(instance)) {
      len = len - 1;
    } else {
      holder = instance;
      ready = true;
    }
  }

  return holder === undefined ? defaultArgument : holder;
}

function dissoc(prop, obj) {
  if (arguments.length === 1) {
    return objHolder => dissoc(prop, objHolder);
  }

  if (obj === null || obj === undefined) {
    return {};
  }

  const willReturn = {};

  for (const p in obj) {
    willReturn[p] = obj[p];
  }

  delete willReturn[prop];
  return willReturn;
}

function divide(x, y) {
  if (arguments.length === 1) {
    return yHolder => divide(x, yHolder);
  }

  return x / y;
}

function drop(dropNumber, x) {
  if (arguments.length === 1) {
    return xHolder => drop(dropNumber, xHolder);
  }

  return x.slice(dropNumber);
}

function dropLast(dropNumber, x) {
  if (arguments.length === 1) {
    return xHolder => dropLast(dropNumber, xHolder);
  }

  return x.slice(0, -dropNumber);
}

function either(x, y) {
  if (arguments.length === 1) {
    return yHolder => either(x, yHolder);
  }

  return input => x(input) || y(input);
}

function endsWith(substr, str) {
  if (arguments.length === 1) {
    return strHolder => endsWith(substr, strHolder);
  }

  return str.endsWith(substr);
}

function F() {
  return false;
}

function find(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => find(fn, arrHolder);
  }

  return arr.find(fn);
}

function findIndex(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => findIndex(fn, arrHolder);
  }

  const len = arr.length;
  let index = -1;

  while (++index < len) {
    if (fn(arr[index], index)) {
      return index;
    }
  }

  return -1;
}

function flatten(arr, willReturn) {
  willReturn = willReturn === undefined ? [] : willReturn;

  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      flatten(arr[i], willReturn);
    } else {
      willReturn.push(arr[i]);
    }
  }

  return willReturn;
}

function flipExport(fn) {
  return (...input) => {
    if (input.length === 1) {
      return holder => fn(holder, input[0]);
    } else if (input.length === 2) {
      return fn(input[1], input[0]);
    }

    return undefined;
  };
}

function flip(fn) {
  return flipExport(fn);
}

function forEach(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => forEach(fn, arrHolder);
  }

  map(fn, arr);
  return arr;
}

function groupBy(fn, list) {
  if (arguments.length === 1) {
    return listHolder => groupBy(fn, listHolder);
  }

  const result = {};

  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    const key = fn(item);

    if (!result[key]) {
      result[key] = [];
    }

    result[key].push(item);
  }

  return result;
}

function has(prop, obj) {
  if (arguments.length === 1) {
    return objHolder => has(prop, objHolder);
  }

  return obj[prop] !== undefined;
}

function head(a) {
  if (typeof a === 'string') {
    return a[0] || '';
  }

  return a[0];
}

function identity(x) {
  return x;
}

function ifElse(condition, ifFn, elseFn) {
  if (ifFn === undefined) {
    return (ifFnHolder, elseFnHolder) => ifElse(condition, ifFnHolder, elseFnHolder);
  } else if (elseFn === undefined) {
    return elseFnHolder => ifElse(condition, ifFn, elseFnHolder);
  }

  return input => {
    const conditionResult = typeof condition === 'boolean' ? condition : condition(input);

    if (conditionResult === true) {
      return ifFn(input);
    }

    return elseFn(input);
  };
}

const inc = x => x + 1;

function includes(target, input) {
  if (arguments.length === 1) {
    return inputHolder => includes(target, inputHolder);
  }

  const ok = Array.isArray(input) || typeof input === 'string';
  if (!ok) return false;
  return input.includes(target);
}

function indexBy(fn, list) {
  if (arguments.length === 1) {
    return listHolder => indexBy(fn, listHolder);
  }

  const result = {};

  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    result[fn(item)] = item;
  }

  return result;
}

function indexOf(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => indexOf(x, arrHolder);
  }

  let index = -1;
  const length = arr.length;

  while (++index < length) {
    if (arr[index] === x) {
      return index;
    }
  }

  return -1;
}

function is$1(xPrototype, x) {
  if (arguments.length === 1) {
    return xHolder => is$1(xPrototype, xHolder);
  }

  return x != null && x.constructor === xPrototype || x instanceof xPrototype;
}

function isNil(x) {
  return x === undefined || x === null;
}

function join(glue, arr) {
  if (arguments.length === 1) {
    return arrHolder => join(glue, arrHolder);
  }

  return arr.join(glue);
}

function keys(x) {
  return Object.keys(x);
}

function lastIndexOf(x, arr) {
  if (arguments.length === 1) {
    return arrHolder => lastIndexOf(x, arrHolder);
  }

  let willReturn = -1;
  arr.map((value, key) => {
    if (equals(value, x)) {
      willReturn = key;
    }
  });
  return willReturn;
}

function length(x) {
  return x.length;
}

function match(regex, x) {
  if (arguments.length === 1) {
    return xHolder => match(regex, xHolder);
  }

  const willReturn = x.match(regex);
  return willReturn === null ? [] : willReturn;
}

function max(x, y) {
  if (arguments.length === 1) {
    return yHolder => max(x, yHolder);
  }

  return y > x ? y : x;
}

function maxBy(fn, x, y) {
  if (arguments.length === 2) {
    return yHolder => maxBy(fn, x, yHolder);
  } else if (arguments.length === 1) {
    return (xHolder, yHolder) => maxBy(fn, xHolder, yHolder);
  }

  return fn(y) > fn(x) ? y : x;
}

function min(x, y) {
  if (arguments.length === 1) {
    return yHolder => min(x, yHolder);
  }

  return y < x ? y : x;
}

function minBy(fn, x, y) {
  if (arguments.length === 2) {
    return yHolder => minBy(fn, x, yHolder);
  } else if (arguments.length === 1) {
    return (xHolder, yHolder) => minBy(fn, xHolder, yHolder);
  }

  return fn(y) < fn(x) ? y : x;
}

function modulo(x, y) {
  if (arguments.length === 1) return yHolder => modulo(x, yHolder);
  return x % y;
}

function multiply(x, y) {
  if (arguments.length === 1) return yHolder => multiply(x, yHolder);
  return x * y;
}

function none(fn, arr) {
  if (arguments.length === 1) return arrHolder => none(fn, arrHolder);
  return arr.filter(fn).length === 0;
}

function not(x) {
  return !x;
}

function nth(index, list) {
  if (arguments.length === 1) return listHolder => nth(index, listHolder);
  const idx = index < 0 ? list.length + index : index;
  return Object.prototype.toString.call(list) === '[object String]' ? list.charAt(idx) : list[idx];
}

function partialCurry(fn, inputArguments = {}) {
  return inputArgumentsHolder => {
    if (type(fn) === 'Async' || type(fn) === 'Promise') {
      return new Promise((resolve, reject) => {
        fn(merge(inputArgumentsHolder, inputArguments)).then(resolve).catch(reject);
      });
    }

    return fn(merge(inputArgumentsHolder, inputArguments));
  };
}

function pathOrRaw(defaultValue, inputPath, inputObject) {
  return defaultTo(defaultValue, path(inputPath, inputObject));
}

const pathOr = curry(pathOrRaw);

function pickAll(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => pickAll(keys, objHolder);
  }

  if (obj === null || obj === undefined) {
    return undefined;
  }

  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;
  const willReturn = {};
  let counter = 0;

  while (counter < keysValue.length) {
    if (keysValue[counter] in obj) {
      willReturn[keysValue[counter]] = obj[keysValue[counter]];
    } else {
      willReturn[keysValue[counter]] = undefined;
    }

    counter++;
  }

  return willReturn;
}

function pluck(keyToPluck, arr) {
  if (arguments.length === 1) return arrHolder => pluck(keyToPluck, arrHolder);
  const willReturn = [];
  map(val => {
    if (!(val[keyToPluck] === undefined)) {
      willReturn.push(val[keyToPluck]);
    }
  }, arr);
  return willReturn;
}

function prepend(x, arr) {
  if (arguments.length === 1) return arrHolder => prepend(x, arrHolder);

  if (typeof arr === 'string') {
    return `${x}${arr}`;
  }

  const clone = arr.concat();
  clone.unshift(x);
  return clone;
}

function prop(key, obj) {
  if (arguments.length === 1) return objHolder => prop(key, objHolder);
  return obj[key];
}

function propEq(key, x, obj) {
  if (x === undefined) {
    return (xHolder, objHolder) => propEq(key, xHolder, objHolder);
  } else if (obj === undefined) {
    return objHolder => propEq(key, x, objHolder);
  }

  return obj[key] === x;
}

function reduce(fn, initialValue, arr) {
  if (initialValue === undefined) {
    return (initialValueHolder, arrHolder) => reduce(fn, initialValueHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => reduce(fn, initialValue, arrHolder);
  }

  return arr.reduce(fn, initialValue);
}

function reject(fn, arr) {
  if (arguments.length === 1) return arrHolder => reject(fn, arrHolder);
  return filter((x, i) => !fn(x, i), arr);
}

function repeat(x, num) {
  if (arguments.length === 1) {
    return numHolder => repeat(x, numHolder);
  }

  const willReturn = Array(num);
  return willReturn.fill(x);
}

function reverse(arr) {
  const clone = arr.concat();
  return clone.reverse();
}

function sortBy(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => sortBy(fn, arrHolder);
  }

  const arrClone = arr.concat();
  return arrClone.sort((a, b) => {
    const fnA = fn(a);
    const fnB = fn(b);
    return fnA < fnB ? -1 : fnA > fnB ? 1 : 0;
  });
}

function split(glue, str) {
  if (arguments.length === 1) return strHolder => split(glue, strHolder);
  return str.split(glue);
}

function splitEvery(num, x) {
  if (arguments.length === 1) return xHolder => splitEvery(num, xHolder);
  const numValue = num > 1 ? num : 1;
  const willReturn = [];
  let counter = 0;

  while (counter < x.length) {
    willReturn.push(x.slice(counter, counter += numValue));
  }

  return willReturn;
}

function startsWith(x, y) {
  if (arguments.length === 1) return yHolder => startsWith(x, yHolder);
  return y.startsWith(x);
}

function subtract(x, y) {
  if (arguments.length === 1) return yHolder => subtract(x, yHolder);
  return x - y;
}

function T() {
  return true;
}

function tail(arr) {
  return drop(1, arr);
}

function takeLast(num, x) {
  if (arguments.length === 1) return xHolder => takeLast(num, xHolder);
  const len = x.length;
  let numValue = num > len ? len : num;

  if (typeof x === 'string') {
    return x.slice(len - numValue);
  }

  numValue = len - numValue;
  return baseSlice(x, numValue, len);
}

function tap(fn, x) {
  if (arguments.length === 1) return xHolder => tap(fn, xHolder);
  fn(x);
  return x;
}

function times(fn, num) {
  if (arguments.length === 1) return numHolder => times(fn, numHolder);
  return map(fn, range(0, num));
}

function toString$1(x) {
  return x.toString();
}

function toUpper(x) {
  return x.toUpperCase();
}

function trim(str) {
  return str.trim();
}

function uniq(arr) {
  let index = -1;
  const willReturn = [];

  while (++index < arr.length) {
    const value = arr[index];

    if (!contains(value, willReturn)) {
      willReturn.push(value);
    }
  }

  return willReturn;
}

function uniqWith(fn, arr) {
  if (arguments.length === 1) return arrHolder => uniqWith(fn, arrHolder);
  let index = -1;
  const len = arr.length;
  const willReturn = [];

  while (++index < len) {
    const value = arr[index];
    const flag = any(willReturnInstance => fn(value, willReturnInstance), willReturn);

    if (!flag) {
      willReturn.push(value);
    }
  }

  return willReturn;
}

function update(index, newValue, arr) {
  if (newValue === undefined) {
    return (newValueHolder, arrHolder) => update(index, newValueHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => update(index, newValue, arrHolder);
  }

  const arrClone = arr.concat();
  return arrClone.fill(newValue, index, index + 1);
}

function values(obj) {
  const willReturn = [];

  for (const key in obj) {
    willReturn.push(obj[key]);
  }

  return willReturn;
}

function without(itemsToOmit, collection) {
  return reduce((accum, item) => !contains(item, itemsToOmit) ? accum.concat(item) : accum, [], collection);
}

/**
 * Taken from 
 * https://github.com/Nozbe/WatermelonDB/blob/master/src/utils/fp/zip/index.js
 */
function zip(left, right) {
  if (right === undefined) {
    return function (right) {
      return zip(left, right);
    };
  }

  var result = [];
  var length = Math.min(left.length, right.length);

  for (var i = 0; i < length; i++) {
    result[i] = [left[i], right[i]];
  }

  return result;
}

function zipObj(x, y) {
  if (arguments.length === 1) return yHolder => zipObj(x, yHolder);
  return x.reduce((prev, xInstance, i) => {
    prev[xInstance] = y[i];
    return prev;
  }, {});
}

const DELAY = 'RAMBDAX_DELAY';

export { DELAY, ok, complement as opposite, complement, allFalse, allTrue, allType, anyFalse, anyTrue, anyType, change, compact, composeAsync, composed, count, debounce, defaultToStrict, defaultToWhen, delay, findInObject, findModify, flatMap, getter, setter, reset, glue, hasPath, headObject, ifElseAsync, includesAny, includesType, inject, interval, isAttach, isFunction$1 as isFunction, isFalsy, isPromise, isType, isValid, mapAsync, mapFastAsync, mapToObject, maybe, memoize$1 as memoize, mergeAll, mergeRight, mergeDeep, nextIndex, pass, once, otherwise, pathEq, piped, pipedAsync, produce, partition, promiseAllObject, pushUniq, random, remove, renameProps, resolve, runTests, s, shuffle, switcher, tapAsync, template, throttle, tryCatch, unless, wait, waitFor, when, whenAsync, where, whereEq, add, adjust, all, allPass, always, any, anyPass, append, assoc, both, compose, concat, contains, curry, dec, defaultTo, dissoc, divide, drop, dropLast, either, endsWith, equals, F, filter, find, findIndex, flatten, flip, forEach, groupBy, has, head, identity, ifElse, inc, includes, indexBy, indexOf, init, is$1 as is, isNil, join, keys, last, lastIndexOf, length, map, match, merge, max, maxBy, min, minBy, modulo, multiply, none, not, nth, omit, partialCurry, path, pathOr, pick, pickAll, pipe, pluck, prepend, prop, propEq, range, reduce, reject, repeat, replace, reverse, sort, sortBy, split, splitEvery, startsWith, subtract, T, tail, take, takeLast, tap, test$1 as test, times, toLower, toString$1 as toString, toUpper, trim, type, uniq, uniqWith, update, values, without, zip, zipObj };
